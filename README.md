# Библиотека autocomplete вводимого текста
Суть проекта заключатеся в _поиске_ записей в _файле_ (.csv), по начальным символам строки.
Проект выполнялся в качестве тестовго задания в компанию __[renue](https://renue.ru/#/)__.
Состояние ответа: _проверяется_.

---

## Как работает программа?

Программа делится на 2 основных модуля: _подготовительный_ и _поисковый_

__Подготовительный__ - модуль отвечающий за подготовление нужных структур данных и их заполнение, в зависимости от введенных данных пользователем при запуске программы.

Всего есть 4 основных структуры, позволяющие осуществлять быстрый поиск по элементам файла:

__1)__ __TreeMap<String, List\<Integer>> valuesColumnAndNumberOfAirportsMap__ - красно-черное дерево, в котором содержатся ключи - значения, выбранной колоноки из файла, значения - список соответствующих аэропортов.
__Пример:__ допустим у нас есть следующие строки в файле (строки специально укорочены для удобства):
__12056,"Yingkou Lanqi Airport","Yingkou","China","YKH"__
__12057,"Shenyang Dongta Airport","Shenyang","China",\N__
__12058,"Shenyang Dongta Airport","Yingkou","China",\N__
Допустим, при запуске программы, вы введете поиск по 2-ой колонке. Тогда эта структура заполнится следующим образом:
__"Yingkou Lanqi Airport": {12056}__
__"Shenyang Dongta Airport": {12057, 12058}__
Таким образом структура позволяет быстро извлекать номера всех аэропортов по поисковому запросу.

__2)__ __HashMap<Integer, String> numberOfAirportsAndValuesColumnMap__ - хэш-таблица, которая хранит в себе ключи - номера аэропортов, значения - значения колонки, по которой осуществляется поиск.
__Пример:__ на всё тех же данных, данная структура заполнится следующим образом:
__12056: "Yingkou Lanqi Airport"__
__12057: "Shenyang Dongta Airport"__
__12058: "Shenyang Dongta Airport"__
С помощью этих данных можно быстро извлекать необходимые значения колонок по номеру аэропорта/

__3)__ __HashMap<Integer, Integer> numberAirportAndStartByteMap__ - хэш-таблица, которая хранит ключи - номера аэропортов, значения - смещение от начала файла, до начала строки, которая содержит соответствующий аэропорт.
__Пример:__
__12056: 0__
__12057: 54__
__12058: 108__

Используется для быстрого парсинга файла в виде результата поиска.

__4)__ __List<String> allSortedValuesOfColumns__ - список, хранящий значения колонки по которой осуществляется поиск в отсортированном виде.
__Пример:__
__["Shenyang Dongta Airport", "Shenyang Dongta Airport", "Yingkou Lanqi Airport"]__

__Поисковый__ - модуль, который работает в момент написания строки пользователем. Его работа осуществляется следующим образом: 

__1)__ С помощью отсортированного списка значений, который получен в подготовительном модуле (пункт 4) ищется подходящий элемент по введенной подстроке пользователем, посредством бинарного поиска (сложность: __O(log2(N))__).

__2)__ Так как список отсортированный, то все лексикографически-похожие записи находятся рядом друг с другом. Алгоритм проходится по этому списку влево(__O(M/2)__), ищя подходящие записи, а затем вправо(__O(M/2)__) и сохраняет идексы: крайнего левого подходящего элемента и крайнего правого, посредством итерации по списку (__O(M)__) + получением элемента в списке (__O(1)__) (сложность: __O(M)__).

__3)__ После того, как мы получили индексы подходящих записей, происходит извлечение этих записей из дерева (__O(log(N))__), полученного на подготовительном этапе (пункт 1) в список (__O(1)__) посредством итераций по списку (__O(M)__) (сложность: __O(Mlog2(N))__).

__4)__ Затем нам необходимо извлечь все номера аэропортов для полученных записей, для этого используется цикл по списку(__O(M)__) + поиск подходящего элемента в дереве(__O(log2(N))__), полученном в подготовительном модуле (пункт 1) (сложность: __O(M*log2(N))__).

__5)__ И последнее, после того, как у нас имеются подходящие номера аэропортов, нам нужно получить смещении от начала файла, в котором находятся нужные нам строки, для этого используется цикл по списку(__O(M)__) + получение элемента в списке(__O(1)__) + получение элемента из HashMap(__O(1)__), полученном в подготовительном модуле (пункт 3) + получение элемента из HashMap (пункт 2) (сложность: __O(M)__).

__M - количество найденных записей__
__N - количество строк в файле__

---

## Сложность и память

#### Сложность программы:

Из преведенных данных в разделе _"Как работает программа?"_ можно составить уравнение:
__log2(N) + M + Mlog2(N) + Mlog2(N) + M__ => log2(N) + 3M + Mlog2(N^2)
Так как количество записей в файле известно (N = 7184), можем упростить уравнение:
т.к __log2(7184) = 13;__
__13 + 3M + Mlog2(N^2)__ => 13 + 3M + 25.6M => 28.6M + 13;
 То есть делаем вывод - сложность алгоритма зависит от количества строк, подходящих под запрос пользователя. Для более точных данных составим уравнение:
__28.6M + 13 < 7184__
__M = 250__ (_максимальное_ количество строк, при котором _сложность_ алгоритма составляет меньше O(N)).

Если пользователь введет подстроку, по которой не найдется ни одной записи, сложность алгоритма составит __O(log(N))__.

#### Память
Как можно увидеть в разделе _"Как работает программа?"_ приложение хранит только 2 колонки из файла после запуска программы. Так же программа успешно работает с ограничением java heap space в __7МБ__.

---

## Использованные технологии

1) Java 11.
2) JUNIT 5.

---

## Установка проекта
1) Склонировать репозиторий
2) Запустить .jar файл, который расположен в директории target командой: _java -Xmx7M -jar <Путь до файла> <Номер колонки>_.

__Примечание:__ не делайте сборку проекта заново, так как пути до файла сбиваются.
